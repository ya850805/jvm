# 虛擬機棧

虛擬機棧概述
------------

### 背景

* 由於跨平台的設計，Java的指令都是根據棧來設計的。不同平台CPU架構不同，所以不能設計為基於寄存器的。
* **優點是跨平台，指令集小，編譯器容易實現，缺點是性能下降，實現同樣的功能需要更多指令**。

### 內存中的棧與堆

* **棧是運行時的單位，堆是存儲的單位**。
* 棧解決程序的運行問題，即程序如何執行，或者說如何處理數據。堆解決的是數據存儲的問題，即數據怎麼放、放在哪。

![image.png](./assets/1711007255822-image.png)

### 虛擬機棧基本內容

* Java虛擬機棧是什麼？
  * Java虛擬機棧(Java Virtual Machine Stack)，早期也叫Java棧。每個線程在創建時都會創建一個虛擬機棧，**其內部保存一個個的棧幀(Stack Frame)，對應一次次的方法調用**，棧是線程私有的。:point_right:參考[StackTest.java](chapter05/StackTest.java)
    ![image.png](./assets/1711007886473-image.png)
* 生命週期
  * 生命週期和線程一致。
* 作用
  * 主管Java程序的運行，保存方法的局部變量(8種基本數據類型、對象的引用地址)、部分結果，並參與方法的調用和返回。
  * 局部變量，他是相比於成員變量(屬性)的。
  * 基本數據變量 vs 引用類型變量(類、數組、接口)

### 虛擬機棧特點

* 棧是一種快速有效的分配存儲方式，訪問速度僅次於程序計數器。
* JVM直接對Java棧的操作只有2個：
  * 每個方法執行，伴隨著**進棧**(入棧、壓棧)。
  * 執行結束後的**出棧**工作。
* 對於棧來說不存在垃圾回收問題。
  * **棧不存在GC，但是可能存在OOM**。

![image.png](./assets/1711008249349-image.png)

### 虛擬機棧的異常

Java虛擬機規範允許**Java棧的大小是動態的或者是固定不變的**。

* 如果採用**固定**大小的Java虛擬機棧，那每一個線程的Java虛擬機棧容量可以在線程創建的時候獨立選定。如果線程請求分配的棧容量超過Java虛擬機棧允許的最大容量，Java虛擬機會拋出一個**StackOverflowError**異常。
* 如果Java虛擬機棧可以**動態擴展**，並且在嘗試擴展的時候無法申請到足夠的內存，或者在創建新的線程時沒有足夠的內存去創建對應的虛擬機棧，那Java虛擬機將會拋出一個**OutOfMemoryError**異常。

參考[StackErrorTest.java](chapter05/StackErrorTest.java)

### 設置棧內存大小

我們可以使用參數`-Xss`選項來設置線程最大棧空間，棧的大小直接決定了函數調用的最大可達深度。
![image.png](./assets/1711092568186-image.png)

ex.

```
-Xss1m
-Xss1024k
-Xss1048576
```

💡 參考[StackErrorTest.java](chapter05/StackErrorTest.java) 運行並設置**VM Option**s `-Xss256k`
![image.png](./assets/1711092809032-image.png)

棧的存儲單位
------------

### 棧中存儲什麼？

* 每個線程都有自己的棧，棧中的數據都是以**棧幀(Stack Frame)的格式**存在。
* 在這個線程上正在執行的**每個方法都各自對應一個棧幀(Stack Frame)**。
* 棧幀是一個內存區塊，是一個數據集，維繫著方法執行過程中的各種數據信息。

### 棧運行原理

* JVM直接對Java棧的操作只有兩個，就是對棧幀的**壓棧**和**出棧**，遵循"**先進後出**"/"**後進先出**" 原則。
* 在一條活動線程中，一個時間點上，只會有一個活動的棧幀。即只有當前正在執行的方法的棧幀(棧頂棧幀)是有效的，這個棧幀被稱為**當前棧幀(Current Frame)**，與當前棧幀相對應的方法就是**當前方法(Current Method)**，定義這個方法的類就是**當前類(Current Class)**。
* 執行引擎運行的所有字節碼指令只針對當前棧幀進行操作。
* 如果在該方法中調用了其他方法，對應的新的棧幀會被創建出來，放在棧的頂端，成為新的當前幀。

![image.png](./assets/1711093397319-image.png)

💡 參考[StackFrameTest.java](chapter05/StackFrameTest.java)，Debug也可以看到Frame結構
![image.png](./assets/1711094051521-image.png)

* **不同線程中所包含的棧幀是不允許存在相互引用的**，即不可能在一個棧幀之中引用另外一個線程的棧幀。
* 如果當前方法調用了其他方法，方法返回之際，當前棧幀會傳回此方法的執行結果給前一個棧幀，接著，虛擬機會丟棄當前棧幀，使得前一個棧幀重新成為當前棧幀。
* Java方法有兩種返回函數的方式，**一種是正常的函數返回，使用`return`指令，另一種是拋出異常(沒有處理的異常)。不管使用哪種方式，都會導致棧幀被彈出**。

### 棧幀的內部結構

每個棧幀中存儲著：

* **局部變量表(Local Variables)**
* **操作數棧(Operand Stack) (或表達式棧)**
* 動態鏈接(Dynamic Linking) (或指向運行時常量池的方法引用)
* 方法返回地址(Return Address) (或方法正常退出或者異常退出的定義)
* 一些附加信息

![image.png](./assets/1711094981531-image.png)

![image.png](./assets/1711095410980-image.png)

局部變量表(Local Variables)
---------------------------

* 局部變量表也被稱為局部變量數組或本地變量表。
* **定義為一個數字數組，主要用於存儲方法參數和定義在方法體內的局部變量，這些數據類型包括各類基本數據類型、對象引用(reference)，以及returnAddress類型**。
* 由於局部變量表是建立在線程的棧上，是線程私有的數據，因此**不存在數據安全問題**。
* **局部變量表所需的容量大小是在編譯期確定下來的**，並保存在方法的Code屬性的maximum local variables數據項中。在方法運行期間是不會改變局部變量表大小的。
* **方法嵌套調用的次數由棧的大小決定**。一般來說，**棧越大，方法嵌套調用次數越多**。對一個函數而言，他的參數和局部變量越多，使得局部變量表膨脹，他的棧幀就越大，以滿足方法調用所需傳遞的信息增大的需求。進而函數調用就會佔用更多的棧空間，導致其嵌套調用次數就會減少。
* **局部變量表中的變量只在當前方法調用中有效**。在方法執行時，虛擬機通過使用局部變量表完成參數直到參數變量列表的傳遞過程。**當方法調用結束後，隨著方法棧幀的銷毀，局部變量表也會隨之銷毀**。

💡 參考[LocalVariablesTest.java](chapter05/LocalVariablesTest.java)，運行後，使用`javap -v LocalVariableTest`解析字節碼文件

![image.png](./assets/1711118664382-image.png)

💡 結論：局部變量表所需的容量大小是在編譯期就確定了。

使用jclasslib來查看

1. 具體的字節碼
   ![image.png](./assets/1711118842099-image.png)
2. 方法異常表信息(`main()`方法沒有拋異常，所以是空的)
   ![image.png](./assets/1711118914249-image.png)
3. Misc顯示有3個局部變量、字節碼有16行
   ![image.png](./assets/1711118924119-image.png)
4. LineNumberTable行號表 :point_right: LineNumber(Java代碼的行號) 和 Start PC(字節碼的行號) 的對應關係
   ![image.png](./assets/1711119652926-image.png)
5. LocalVariableTable局部變量表
   ![image.png](./assets/1711119804075-image.png)
   * Start PC：字節碼指令的行號
   * Start PC(變量起始作用位置，從聲明的下一行有效)和Length(作用的長度)合起來描述當前**變量作用域的範圍**
   * Description中`Ljava/lang/String`中的`L`代表引用類型

### 關於Slot的理解

* 參數值的存放總是在局部變量數組的index0開始，到數組長度-1的索引結束。
* **局部變量表，最基本的存儲單元是Slot(變量槽)**。
* 局部變量表中存放編譯其可知的各種基本數據類型(8種)，引用類型(reference)，returnAddress類型的變量。
* 在局部變量表裡，**32位以內的類型只佔用一個slot(包括returnAddress類型)，64位的類型(`doubl`和`long`)佔用2個slot**。
  * `byte`、`short`、`char`在存儲前被轉換為`int`，`boolean`也被轉換為`int`，`0`表示`false`，非`0`表示`true`。
  * `double`和`long`則佔據2個slot。
* JVM會為局部變量表中的每一個slot都分配一個訪問索引，通過這個索引即可成功訪問到局部變量表中指定的局部變量值。
* 當一個實例方法被調用的時候，他的方法參數和方法體內部定義的局部變量將會**按照順序被複製**到局部變量表中的每一個Slot上。
* **如果需要訪問局部變量表中一個64Bit(佔用2個Slot)的局部變量值時，只需要使用前面的一個索引即可**(例如訪問`long`或`double`的變量)。
  ![image.png](./assets/1711121519011-image.png)
* 如果當前幀是由**構造方法**或者**實例方法**創建的，那麼**該對象引用的`this`將會存放在index0的slot處**，其餘的參數按照參數表順序繼續排列。
  ![image.png](./assets/1711121388117-image.png)

![image.png](./assets/1711121236719-image.png)

### Slot的重複利用

**棧幀中的局部變量表中槽位是可以重用的**，如果一個局部變量過了其作用域，那麼在其作用域之後聲明的新的局部變量就很有可能會複用過期局部變量的槽位，從而達到**節省資源**的目的。

💡 參考[LocalVariablesTest.java](chapter05/LocalVariablesTest.java)的`test4()`方法，`b`出了大括號就銷毀了，不過數組的位置已經開闢了，再聲明`c`的時候就重複利用index2的位置(原本是變量`b`的位置)。

![image.png](./assets/1711121940687-image.png)

### 靜態變量與局部變量的對比

> 變量的分類：
> 
> 1. 按照數據類型分：基本數據類型、引用數據類型。
> 2. 按照在類中聲明的位置分：
>    1. 成員變量：在使用前，都經過默認初始化賦值。
>       1. 類變量：linking的prepare階段，給類變量默認賦值 ---> initialization階段給類變量顯式及靜態代碼塊賦值。
>       2. 實例變量：隨著對象的創建，會在堆空間中分配實例變量空間，並進行默認賦值。
>    2. 局部變量：在使用前，必須要進行顯式賦值的！否則編譯不通過。

* 參數表分配完畢之後，再根據方法體內定義的變量的順序和作用域分配。
* 我們知道類變量表有2次初始化的機會，第一次是在"**準備階段**"，執行系統初始化，對類變量設置零值，另一次則是在"**初始化**"階段，賦予程序員在代碼快中定義的初始值。
* 和類變量初始化不同的是，局部變量表不存在系統初始化的過程，這意味著一但定義了局部變量則**必須人為初始化**，否則無法使用。

*補充說明*：

* 在棧幀中，與性能條優關係最為密切的部分就是前面提到的局部變量表。在方法執行時，虛擬機使用局部變量表完成方法的傳遞。
* **局部變量表中的變量也是重要的垃圾回收根節點，只要被局部變量表中直接或間接引用的對象都不會被回收**。

