# 虛擬機棧

虛擬機棧概述
------------

### 背景

* 由於跨平台的設計，Java的指令都是根據棧來設計的。不同平台CPU架構不同，所以不能設計為基於寄存器的。
* **優點是跨平台，指令集小，編譯器容易實現，缺點是性能下降，實現同樣的功能需要更多指令**。

### 內存中的棧與堆

* **棧是運行時的單位，堆是存儲的單位**。
* 棧解決程序的運行問題，即程序如何執行，或者說如何處理數據。堆解決的是數據存儲的問題，即數據怎麼放、放在哪。

![image.png](./assets/1711007255822-image.png)

### 虛擬機棧基本內容

* Java虛擬機棧是什麼？
  * Java虛擬機棧(Java Virtual Machine Stack)，早期也叫Java棧。每個線程在創建時都會創建一個虛擬機棧，**其內部保存一個個的棧幀(Stack Frame)，對應一次次的方法調用**，棧是線程私有的。:point_right:參考[StackTest.java](chapter05/StackTest.java)
    ![image.png](./assets/1711007886473-image.png)
* 生命週期
  * 生命週期和線程一致。
* 作用
  * 主管Java程序的運行，保存方法的局部變量(8種基本數據類型、對象的引用地址)、部分結果，並參與方法的調用和返回。
  * 局部變量，他是相比於成員變量(屬性)的。
  * 基本數據變量 vs 引用類型變量(類、數組、接口)

### 虛擬機棧特點

* 棧是一種快速有效的分配存儲方式，訪問速度僅次於程序計數器。
* JVM直接對Java棧的操作只有2個：
  * 每個方法執行，伴隨著**進棧**(入棧、壓棧)。
  * 執行結束後的**出棧**工作。
* 對於棧來說不存在垃圾回收問題。
  * **棧不存在GC，但是可能存在OOM**。

![image.png](./assets/1711008249349-image.png)

### 虛擬機棧的異常

Java虛擬機規範允許**Java棧的大小是動態的或者是固定不變的**。

* 如果採用**固定**大小的Java虛擬機棧，那每一個線程的Java虛擬機棧容量可以在線程創建的時候獨立選定。如果線程請求分配的棧容量超過Java虛擬機棧允許的最大容量，Java虛擬機會拋出一個**StackOverflowError**異常。
* 如果Java虛擬機棧可以**動態擴展**，並且在嘗試擴展的時候無法申請到足夠的內存，或者在創建新的線程時沒有足夠的內存去創建對應的虛擬機棧，那Java虛擬機將會拋出一個**OutOfMemoryError**異常。

參考[StackErrorTest.java](chapter05/StackErrorTest.java)

### 設置棧內存大小

我們可以使用參數`-Xss`選項來設置線程最大棧空間，棧的大小直接決定了函數調用的最大可達深度。
![image.png](./assets/1711092568186-image.png)

ex.

```
-Xss1m
-Xss1024k
-Xss1048576
```

💡 參考[StackErrorTest.java](chapter05/StackErrorTest.java) 運行並設置**VM Option**s `-Xss256k`
![image.png](./assets/1711092809032-image.png)

棧的存儲單位
------------

### 棧中存儲什麼？

* 每個線程都有自己的棧，棧中的數據都是以**棧幀(Stack Frame)的格式**存在。
* 在這個線程上正在執行的**每個方法都各自對應一個棧幀(Stack Frame)**。
* 棧幀是一個內存區塊，是一個數據集，維繫著方法執行過程中的各種數據信息。

### 棧運行原理

* JVM直接對Java棧的操作只有兩個，就是對棧幀的**壓棧**和**出棧**，遵循"**先進後出**"/"**後進先出**" 原則。
* 在一條活動線程中，一個時間點上，只會有一個活動的棧幀。即只有當前正在執行的方法的棧幀(棧頂棧幀)是有效的，這個棧幀被稱為**當前棧幀(Current Frame)**，與當前棧幀相對應的方法就是**當前方法(Current Method)**，定義這個方法的類就是**當前類(Current Class)**。
* 執行引擎運行的所有字節碼指令只針對當前棧幀進行操作。
* 如果在該方法中調用了其他方法，對應的新的棧幀會被創建出來，放在棧的頂端，成為新的當前幀。

![image.png](./assets/1711093397319-image.png)

💡 參考[StackFrameTest.java](chapter05/StackFrameTest.java)，Debug也可以看到Frame結構
![image.png](./assets/1711094051521-image.png)

* **不同線程中所包含的棧幀是不允許存在相互引用的**，即不可能在一個棧幀之中引用另外一個線程的棧幀。
* 如果當前方法調用了其他方法，方法返回之際，當前棧幀會傳回此方法的執行結果給前一個棧幀，接著，虛擬機會丟棄當前棧幀，使得前一個棧幀重新成為當前棧幀。
* Java方法有兩種返回函數的方式，**一種是正常的函數返回，使用`return`指令，另一種是拋出異常(沒有處理的異常)。不管使用哪種方式，都會導致棧幀被彈出**。

### 棧幀的內部結構

每個棧幀中存儲著：

* **局部變量表(Local Variables)**
* **操作數棧(Operand Stack) (或表達式棧)**
* 動態鏈接(Dynamic Linking) (或指向運行時常量池的方法引用)
* 方法返回地址(Return Address) (或方法正常退出或者異常退出的定義)
* 一些附加信息

![image.png](./assets/1711094981531-image.png)

![image.png](./assets/1711095410980-image.png)









