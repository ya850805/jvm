# JVM與Java體系結構

Java：跨平台的語言
------------------

![image.png](./assets/image.png)

*Write once, run anywhere.*

JVM：跨語言的平台
-----------------

![image.png](./assets/1710326613124-image.png)

* Java虛擬機的設計者們通過JSR-292規範基本實現在**Java虛擬機平台上運行非Java語言編寫的代碼**。
* Java虛擬機根本不關心運行在其內部的程序到底是使用什麼語言編寫的，**他只關心"字節碼"文件**。也就是說java虛擬機擁有語言無關性，並不會單純與Java語言終身綁定，只要其他編程語言的編譯結果滿足並包含Java虛擬機的內部指令集、符號表以及其他的輔助信息，他就是一個有效的字節碼文件，能夠被虛擬機識別和運行。

**Java不是最強大的語言，但是JVM是最強大的虛擬機**

字節碼
------

* 我們平時說的Java字節碼，指的是用Java語言編譯成的字節碼。準確的說任何能在JVM平台上執行的字節碼格式都是一樣的。所以應該統稱為：**JVM字節碼**。
* 不同的編譯器，可以編譯出相同的字節碼文件，字節碼文件也可以在不同的JVM上運行。
* Java虛擬機與Java語言並沒有必然的關係，他只與特定的二進制文件格式-`.class`文件格式所關聯，`.class`文件中包含了Java虛擬機指令集(稱為字節碼、Bytecodes)和符號表，還有一些其他輔助信息。

多語言混合編程
--------------

Java平台上的多語言混合編程正成為主流，通過特定領域的語言去解決特定領域的問題是當前軟件開發應對日趨複雜的項目需求的一個方向。

試想一下，在一個項目中，并行處理用Clojure語言編寫，展示層用JRuby/Rails，中間層用Java，每個應用層都將使用不同的編程語言來完成，而且接口對每一層的開發者都是透明的，**各種語言之間的交互不存在任何困難，就像使用自己語言的原生API一樣方便，因為他們最終都運行在一個虛擬機之上**。

對這些運行於Java虛擬機之上、Java之外的語言來自系統級的、底層的支持正在迅速增強，以JSR-292為和新的一系列項目和功能改進，**推動Java虛擬機從"Java語言的虛擬機"向"多語言虛擬機"的方向發展**。

Open JDK和Oracle JDK
--------------------

![image.png](./assets/1710407397549-image.png)

JDK11之前OracleJDK還存在一些OpenJDK中沒有的、閉源的功能。但在JDK11中，我們可以認為OpenJDK和OracleJDK代碼實質上已經完全一致。

虛擬機
------

* 所謂虛擬機(Virtual Machine)，就是一台虛擬的計算機。他是一款軟件，用來執行一系列虛擬計算機指令。大體上，虛擬機可以分為**系統虛擬機**和**程序虛擬機**。
  * Visual Box, WMware就屬於系統虛擬機，他們完全是**對物理計算機的仿真**，提供了一個可運行完整操作系統的軟件平台。
  * Java虛擬機是一種程序虛擬機，他**專門為執行單個計算機程序而設計**，在Java虛擬機中執行的指令我們稱為Java字節碼指令。
* 無論是系統虛擬機還是程序虛擬機，在上面運行的軟件都被限制於虛擬機提供的資源中。

**Java虛擬機**：

* Java虛擬機是一台執行Java字節碼的虛擬計算機，它擁有獨立的運行機制，其運行的Java字節碼也未必由Java語言編譯而成。
* JVM平台的各種語言可以共享Java虛擬機帶來的跨平台性、優秀的垃圾回收器，以及可靠的即時編譯器。
* **Java技術的核心就是Java虛擬機(JVM)**，因為所有的Java程序都運行在Java虛擬機內部。
* 作用：**Java虛擬機就是二進制字節碼的運行環境**，負責裝載字節碼到其內部，解釋/編譯為對應平台商的機器指令執行。每一條Java指令，Java虛擬機規範中都有詳細定義，如怎麼操作數，怎麼處理操作數，處理結果放在哪裡。
* 特點：
  * 一次編譯，到處運行
  * 自動內存管理
  * 自動垃圾回收功能

JVM的位置
---------

![image.png](./assets/1710408336690-image.png)

JVM是運行在操作系統之上的，他與硬件沒有直接的交互。

![image.png](./assets/1710408420486-image.png)

**`.java`使用前端編譯器`javac`編譯成`.class`，解釋運行涉及到後端編譯器(JVM層面的內容，Java HotSpot Client and Server VM)**。

JVM整體結構
-----------

![image.png](./assets/1710408698545-image.png)

💡 方法區、堆是**每個線程共有的**。
💡 虛擬機棧(Java棧)、本地方法棧、程序計數器是**每個線程都有一份的(私有的)**。

* HotSpot VM是目前市面上高性能虛擬機的代表作之一(OpenJDK和OracleJDK公用的虛擬機)。
* 它採用解釋器與即時編譯器並存的架構。
* 執行引擎：負責**翻譯成機器語言(0101..)**。

Java代碼執行流程
----------------

![image.png](./assets/1710409311556-image.png)

JVM的架構模型
-------------

Java編譯器輸入的指令流基本上是一種基於**棧的指令集架構**，另一種指令集架構則是基於**寄存器的指令集架構**。

棧式架構的特點：

* 設計和實現更簡單，適用於資源受限的系統。
* 避開了寄存器的分配難題。使用零地址指令方式分配。
* 指令流中的指令大部分是零地址指令，其執行過程依賴於操作棧。指令集更小，編譯器容易實現。
* 不需要硬件支持，可移植性更好，更好實現跨平台。
* 舉例：(8個指令集)
  ```
  iconst_2 //常量2入棧
  istore_1
  iconst_3 // 常量3入棧
  istore_2
  iload_1
  iload_2
  iadd //常量2/3出棧
  istore_0 // 结果5入棧
  ```

寄存器架構的特點：

* 典型的應用是x86的二進制指令集：比如傳統的PC以及Android的Davlik虛擬機。
* **指令集架構則完全依賴硬件，可移植性差**。
* **性能優秀和執行更高效**。
* 花費更少的指令去完成一項操作。
* 大部分情況，基於寄存器架構的指令集往往都以一地址指令、二地址指令和三地址指令為主，而基於棧式架構的指令集是以零地址指令為主。
* 舉例：
  ```
  mov eax,2 //將eax寄存器的值設為1
  add eax,3 //使eax寄存器的值加3
  ```

案例：運行[StackStructureTest.java](StackStructureTest.java) 後，到target目錄，使用命令`javap -v StackStructureTest`可以看到對應的字節碼指令。

總結：

* 由於跨平台性的設計，Java的指令都是根據棧來設計的。不同平台CPU架構不同，所以不能設計為基於寄存器的。優點是跨平台、指令集小，編譯容易實現，缺點是性能下降，實現同樣的功能需要更多的指令。
* **棧：跨平台性、指令集小、指令多。執行性能比寄存器差**。

JVM的生命週期
-------------

**虛擬機的啟動**：Java虛擬機的啟動是通過引導類加載器(bootstrap class loader)創建一個初始類(initial class)來完成的，這個類是由虛擬機的具體實現指定的。

**虛擬機的運行**：

* 一個運行中的Java虛擬機有著一個清晰的任務：執行Java程序。
* 程序開始執行他才運行，程序結束時他就停止。
* **執行一個所謂的Java程序的時候，真真正正在執行的是一個叫做Java虛擬機的進程**。(可以使用`jps`命令查看當前執行中的進程)

**虛擬機的結束**(有如下的幾種情況)：

* 程序正常結束。
* 程序在執行過程中遇到了異常或錯誤而異常終止。
* 由於操作系統出現錯誤而導致Java虛擬機進程終止。
* 某線程調用`System`的`exit()`方法，或`Runtime`類的`halt()`方法，並且Java安全管理器也允許這次exit或halt的操作。
* 除此之外，JNI規範描述了用JNI Invocation API來加載或卸載Java虛擬機時，Java虛擬機得退出情況。

